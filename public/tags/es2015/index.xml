<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Es2015 on TLDR Dev Notes</title>
    <link>/tags/es2015/</link>
    <description>Recent content in Es2015 on TLDR Dev Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>TOML &amp;copy; 2017. All rights reserved.</copyright>
    <lastBuildDate>Tue, 07 Mar 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/es2015/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ES6 (ES2015) and Beyond with Node.js</title>
      <link>/javascript/es2015/es6-es2015-beyond-with-node-js-javascript/</link>
      <pubDate>Tue, 07 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/javascript/es2015/es6-es2015-beyond-with-node-js-javascript/</guid>
      <description>tl;dr # initialize npm init -y # install dependencies npm i -D babel-cli babel-preset-es2015 babel-preset-stage-0 nodemon # Babel config touch .babelrc echo &#39;{ presets: [ &amp;quot;es2015&amp;quot;, &amp;quot;stage-0&amp;quot; ] }&#39; &amp;gt;&amp;gt; .babelrc # directory structure # mkdir src &amp;amp;&amp;amp; touch src/index.js # add some es6 code to index.js for testing # run Babel babel-node src/index.js # add npm run scripts  Note: For the sake of simplicity, i use ES6 and ES2015 interchangeably.</description>
    </item>
    
    <item>
      <title>[ES2015] Default values</title>
      <link>/javascript/es2015/es2015-default-vlaues/</link>
      <pubDate>Mon, 23 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/javascript/es2015/es2015-default-vlaues/</guid>
      <description>Default Values Here&amp;rsquo;s how we used to do default parameter values before.. Say we have a function that returns 42 is no parameter value is provided and if a value is passed, it returns the value.
function foo (x) { x = x || 42 // Using the OR operand `||` to give 42 if x is false return x } foo(3) // 3 foo(99) // 99 foo(0) // 42 eh?</description>
    </item>
    
    <item>
      <title>[ES2015] Arrow Functions</title>
      <link>/javascript/es2015/es2015-arrow-functions/</link>
      <pubDate>Mon, 16 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/javascript/es2015/es2015-arrow-functions/</guid>
      <description>Arrow Functions Arrow functions are anonymous function expressions. They don&amp;rsquo;t show up in stack traces.
Pros  Shorter syntax. You get to remove function, return and some {..} Shines with this keyword. The arrow function doesn&amp;rsquo;t have it&amp;rsquo;s own this so we automatically get a lexical this (bind to the outer context). Skipping .bind(this)  Cons  Show up as anonymous in stack trace, makes debugging/troubleshooting hard. Imagine minified code, error at line 1, character 32712.</description>
    </item>
    
    <item>
      <title>[ES2015] Generators</title>
      <link>/javascript/es2015/es2015-generators/</link>
      <pubDate>Tue, 27 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/javascript/es2015/es2015-generators/</guid>
      <description>Generators Generators are functions that can be paused and resumed later. A generator can contain multiple yield statements. At each yield, the generator will pause.</description>
    </item>
    
    <item>
      <title>[ES2015] Async/Await Functions</title>
      <link>/javascript/es2015/es2015-async-await/</link>
      <pubDate>Thu, 22 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/javascript/es2015/es2015-async-await/</guid>
      <description>Async/Await Functions declare an async function that will allow us to wait for other functions. we can only await inside an async function, and we can only await a promise.
Async/await is an ES2016 (ES7) feature, so you&amp;rsquo;ll need a transpiler. See http://babeljs.io/docs/plugins/preset-latest/
npm i -g babel-cli  add a minimal .babelrc inside your project dir
{ &amp;quot;presets&amp;quot;: [ &amp;quot;latest&amp;quot; ] }  and install packages (locally, inside your project folder)</description>
    </item>
    
    <item>
      <title>[ES2015] Classes in JavaScript</title>
      <link>/javascript/es2015/es2015-classes/</link>
      <pubDate>Thu, 22 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/javascript/es2015/es2015-classes/</guid>
      <description>ES2015 / ES6 Classes in JavaScript Classes in JS don&amp;rsquo;t give JS an OO nature, JS remains Prototypal. Classes introduced in ES6 are mainly syntax sugar.
&amp;quot;use strict&amp;quot;; // CLASS class User{ // Constructor // takes any values/attr you want to set constructor(username, email, password) { this.username = username // Whatever username we passed in is now this Class&#39;s (instance) username this.email = email this.password = password } static countUsers () { console.</description>
    </item>
    
    <item>
      <title>[ES2015] ES6 Features Overview </title>
      <link>/javascript/es2015/es2015-overview/</link>
      <pubDate>Thu, 22 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/javascript/es2015/es2015-overview/</guid>
      <description>ES6 Features (ES2015) Arrow Function Syntax  MDN: Arrow Function Syntax Babel Docs Treehouse: Arrow Function Syntax YouTube: Arrow Function Syntax  Arrow function syntax is supported in all major browsers.
// Function Declaration function divide1(a,b) { return a/b; } // Function Expression const divide2 = function(a,b) { return a/b; } // Arrow Function Expression const divide3 = (a,b) =&amp;gt; { return a/b; } // Arrow Function Concise const divide4 = (a,b) =&amp;gt; a/b;  Arrow (aka lambda) functions define the function to the instance of wherever it was created (or something like that, requires citation).</description>
    </item>
    
    <item>
      <title>[ES2015] Map object</title>
      <link>/javascript/es2015/es2015-map/</link>
      <pubDate>Thu, 22 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/javascript/es2015/es2015-map/</guid>
      <description>Map  The Map object is a simple key/value map. Any value (both objects and primitive values) may be used as either a key or a value.
 You set and get values to/from a Map.
&#39;use strict&#39;; let classroom = new Map(); let stevenJ = { name: &#39;Steven&#39;, age: 22 }, sarah = { name: &#39;Sarah&#39;, age: 23 }, stevenS = { name: &#39;Steven&#39;, age: 22 }; classroom.set(&#39;stevenJ&#39;, stevenJ) classroom.</description>
    </item>
    
    <item>
      <title>[ES2015] Promises</title>
      <link>/javascript/es2015/es2015-promises/</link>
      <pubDate>Thu, 22 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/javascript/es2015/es2015-promises/</guid>
      <description>Promises Promises are like callback functions, but so much better. Promises are meant to save you from callback hell.
ES6 feature, started out as libraries. Natively supported in all modern browsers.
A promise is a pattern for handling asynchronous operations. The promise allows you to call a method called &amp;ldquo;then&amp;rdquo; that lets you specify the function(s) to use as the callbacks.
A promise is an eventual value.
three states</description>
    </item>
    
    <item>
      <title>[ES2015] Set object</title>
      <link>/javascript/es2015/es2015-set/</link>
      <pubDate>Thu, 22 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/javascript/es2015/es2015-set/</guid>
      <description>Set  https://teamtreehouse.com/library/set https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set  A Set is not an Array but it can behave like one. Itâ€™s a collection of unique values.
 The Set object lets you store unique values of any type, whether primitive values or object references.
 let showroom = new Set() let Prius = {make: &#39;Toyota&#39;, model: &#39;Prius 2017&#39;}, Civic = {make: &#39;Honda&#39;, model: &#39;Civic 2016&#39;}, A6 = { make: &#39;Audi&#39;, model: &#39;A6 Sedan 2017&#39;} showroom.</description>
    </item>
    
    <item>
      <title>[ES2015] var, let and const</title>
      <link>/javascript/es2015/es2015-var-let-const/</link>
      <pubDate>Thu, 22 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/javascript/es2015/es2015-var-let-const/</guid>
      <description>var, let and const  using var is an issue because var is hoisted. var is function scope, let is block scope. let is the new var. const is a constant. it is for something that is only going to be defined once. You can not redefine const. const is not exactly immutable, the values in const can sometimes be changed, for example if it&amp;rsquo;s an object and you want to chaneg property values inside, you can.</description>
    </item>
    
  </channel>
</rss>