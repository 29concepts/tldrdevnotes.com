<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Concepts on TLDR Dev Notes</title>
    <link>localhost/hugo-tldr/tags/concepts/</link>
    <description>Recent content in Concepts on TLDR Dev Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>TOML &amp;copy; 2017. All rights reserved.</copyright>
    <lastBuildDate>Sat, 11 Nov 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="localhost/hugo-tldr/tags/concepts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Event Capturing, Event Bubbling and Event Delegation</title>
      <link>localhost/hugo-tldr/javascript/browser-events-bubbling-capture-delegation/</link>
      <pubDate>Sat, 11 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>localhost/hugo-tldr/javascript/browser-events-bubbling-capture-delegation/</guid>
      <description>Bubbling and Capturing are behaviours, a way of propagating events to multiple handlers Event propagation is the blanket term used for both event bubbling and event capturing. It is the process of calling all the listeners for the given event type. Bubbling, capturing and delegation are not browser features, they&amp;rsquo;re all models of dealing with events  Event propagation Event propagation is the process of calling all the listeners for the given event type.</description>
    </item>
    
    <item>
      <title>[ES2015] Arrow Functions</title>
      <link>localhost/hugo-tldr/javascript/es2015/es2015-arrow-functions/</link>
      <pubDate>Mon, 16 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>localhost/hugo-tldr/javascript/es2015/es2015-arrow-functions/</guid>
      <description>Arrow Functions Arrow functions are anonymous function expressions. They don&amp;rsquo;t show up in stack traces.
Pros  Shorter syntax. You get to remove function, return and some {..} Shines with this keyword. The arrow function doesn&amp;rsquo;t have it&amp;rsquo;s own this so we automatically get a lexical this (bind to the outer context). Skipping .bind(this)  Cons  Show up as anonymous in stack trace, makes debugging/troubleshooting hard. Imagine minified code, error at line 1, character 32712.</description>
    </item>
    
    <item>
      <title>[ES2015] Generators</title>
      <link>localhost/hugo-tldr/javascript/es2015/es2015-generators/</link>
      <pubDate>Tue, 27 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>localhost/hugo-tldr/javascript/es2015/es2015-generators/</guid>
      <description>Generators Generators are functions that can be paused and resumed later. A generator can contain multiple yield statements. At each yield, the generator will pause.</description>
    </item>
    
    <item>
      <title>[ES2015] Async/Await Functions</title>
      <link>localhost/hugo-tldr/javascript/es2015/es2015-async-await/</link>
      <pubDate>Thu, 22 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>localhost/hugo-tldr/javascript/es2015/es2015-async-await/</guid>
      <description>Async/Await Functions declare an async function that will allow us to wait for other functions. we can only await inside an async function, and we can only await a promise.
Async/await is an ES2016 (ES7) feature, so you&amp;rsquo;ll need a transpiler. See http://babeljs.io/docs/plugins/preset-latest/
npm i -g babel-cli  add a minimal .babelrc inside your project dir
{ &amp;quot;presets&amp;quot;: [ &amp;quot;latest&amp;quot; ] }  and install packages (locally, inside your project folder)</description>
    </item>
    
    <item>
      <title>[ES2015] Classes in JavaScript</title>
      <link>localhost/hugo-tldr/javascript/es2015/es2015-classes/</link>
      <pubDate>Thu, 22 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>localhost/hugo-tldr/javascript/es2015/es2015-classes/</guid>
      <description>ES2015 / ES6 Classes in JavaScript Classes in JS don&amp;rsquo;t give JS an OO nature, JS remains Prototypal. Classes introduced in ES6 are mainly syntax sugar.
&amp;quot;use strict&amp;quot;; // CLASS class User{ // Constructor // takes any values/attr you want to set constructor(username, email, password) { this.username = username // Whatever username we passed in is now this Class&#39;s (instance) username this.email = email this.password = password } static countUsers () { console.</description>
    </item>
    
    <item>
      <title>[ES2015] Map object</title>
      <link>localhost/hugo-tldr/javascript/es2015/es2015-map/</link>
      <pubDate>Thu, 22 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>localhost/hugo-tldr/javascript/es2015/es2015-map/</guid>
      <description>Map  The Map object is a simple key/value map. Any value (both objects and primitive values) may be used as either a key or a value.
 You set and get values to/from a Map.
&#39;use strict&#39;; let classroom = new Map(); let stevenJ = { name: &#39;Steven&#39;, age: 22 }, sarah = { name: &#39;Sarah&#39;, age: 23 }, stevenS = { name: &#39;Steven&#39;, age: 22 }; classroom.set(&#39;stevenJ&#39;, stevenJ) classroom.</description>
    </item>
    
    <item>
      <title>[ES2015] Promises</title>
      <link>localhost/hugo-tldr/javascript/es2015/es2015-promises/</link>
      <pubDate>Thu, 22 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>localhost/hugo-tldr/javascript/es2015/es2015-promises/</guid>
      <description>Promises Promises are like callback functions, but so much better. Promises are meant to save you from callback hell.
ES6 feature, started out as libraries. Natively supported in all modern browsers.
A promise is a pattern for handling asynchronous operations. The promise allows you to call a method called &amp;ldquo;then&amp;rdquo; that lets you specify the function(s) to use as the callbacks.
A promise is an eventual value.
three states</description>
    </item>
    
    <item>
      <title>Higher Order Functions</title>
      <link>localhost/hugo-tldr/programming/higher-order-functions/</link>
      <pubDate>Sat, 03 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>localhost/hugo-tldr/programming/higher-order-functions/</guid>
      <description>Higher-order Functions - Any complicated function that was composed by combining simple functions is a higher order function. - Functions that operate on other functions, either by taking them as arguments or by returning them, are called higher-order functions. - Eloquent JavaScript - A higher-order function is a function that takes other functions as arguments and/or returns a function as it&#39;s result. - Wikipedia  Notes  Functions are values.</description>
    </item>
    
  </channel>
</rss>